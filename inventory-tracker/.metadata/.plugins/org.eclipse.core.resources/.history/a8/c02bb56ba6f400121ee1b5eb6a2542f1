package gui.reports.productstats;

import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import core.model.InventoryManager;
import core.model.Item;
import core.model.Product;

public class ProductStatsCalculatorImpl implements ProductStatsCalculator {

	Date startDate;
	Date endDate;
	Iterable<Item> currentItems;
	Iterable<Item> removedItems;

	public ProductStatsCalculatorImpl() {

	}

	public void setValues(Date startDate, Date endDate,
			Iterable<Item> currentItems, Iterable<Item> removedItems) {
		this.startDate = startDate;
		this.endDate = endDate;
		this.currentItems = currentItems;
		this.removedItems = removedItems;
	}

	@Override
	public int calculateCurrentSupply() {
		int currentSupply = 0;
		Iterator<Item> iter = currentItems.iterator();
		while (iter.hasNext()) {
			Item item = iter.next();
			currentSupply++;
		}
		return currentSupply;
	}

	@Override
	public double calculateAverageSupply() {
		double averageSupply = 0;
		int numberOfDays = 0;
		int netDaysItemsStored = 0;
		Item item;
		Iterator<Item> iterCur = currentItems.iterator();
		Iterator<Item> iterRem = removedItems.iterator();
		while (iterCur.hasNext()) {
			item = iterCur.next();
			if (!item.getEntryDate().after(endDate)) {
				netDaysItemsStored += calculateDayDifference(
						getLatestDate(item.getEntryDate(), startDate), endDate);
			}
		}
		while (iterRem.hasNext()) {
			item = iterRem.next();
			if (!(item.getEntryDate().after(endDate))
					|| item.getExitDate().before(startDate)) {
				netDaysItemsStored += calculateDayDifference(
						getLatestDate(item.getEntryDate(), startDate),
						getEarliestDate(item.getExitDate(), endDate));
			}
		}
		averageSupply = netDaysItemsStored
				/ calculateDayDifference(startDate, endDate);
		return averageSupply;
	}

	@Override
	public int calculateMinimumSupply() {
		int minimumSupply = (int) calculateAverageSupply() + 1;
		Calendar cal = Calendar.getInstance();
		cal.setTime(startDate);
		Item item;
		while (!cal.getTime().equals(endDate)) {
			Iterator<Item> iterCur = currentItems.iterator();
			Iterator<Item> iterRem = removedItems.iterator();
			int itemsStoredinDate = 0;
			// iterate through current items
			while (iterCur.hasNext()) {
				item = iterCur.next();
				if (item.getEntryDate().before(cal.getTime())) {
					itemsStoredinDate++;
				}
			}
			while (iterRem.hasNext()) {
				item = iterRem.next();
				if (item.getEntryDate().before(cal.getTime())
						&& item.getExitDate().after(cal.getTime())) {
					itemsStoredinDate++;
				}
			}
			if (itemsStoredinDate < minimumSupply) {
				minimumSupply = itemsStoredinDate;
			}
		}
		return minimumSupply;
	}

	@Override
	public int calculateMaximumSupply() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int calculateItemsUsed() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int calculateItemsAdded() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public double calculateAverageAgeUsed() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int calculateMaximumAgeUsed() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public double calculateAverageAgedCurrent() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int calculateMaximumAgeCurrent() {
		// TODO Auto-generated method stub
		return 0;
	}

	public int calculateDayDifference(Date begin, Date end) {
		return (int) (end.getTime() - begin.getTime()) / (1000 * 60 * 60 * 24);
	}

	public Date getEarliestDate(Date date1, Date date2) {
		if (date1.before(date2)) {
			return date1;
		}
		return date2;
	}

	public Date getLatestDate(Date date1, Date date2) {
		if (date1.after(date2)) {
			return date1;
		}
		return date2;
	}
}
